## 1 C++和C的区别？

设计思想：C++是面向对象，C面向过程的结构化语言

语言基础：C++具有封装、继承、多态三种特性；C++与C相比增加了类型安全的功能（强制类型转换）；C++支持泛型编程，如模板类、函数模板等

## 2 C++中static关键字

### 2.1  全局静态变量：

在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.

静态存储区，在整个程序运行期间一直存在。

初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

 

### 2.2  局部静态变量：

在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。

内存中的位置：静态存储区

初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

 

### 2.3  静态函数：

在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。

函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；

warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

 

### 2.4  类的静态成员：

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用

 

### 2.5  类的静态方法：

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。

在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);

比如STL中的allocator

 

 

 

## 3 C++中const关键字

 

## 4 C++中volatile关键字

 

## 5 C++中的四种cast转换

### 5.1  const_cast

将cosnt变量转为非const变量

### 5.2  static_cast

各种隐式类型转换，非const转cosnt，void*转指针，static_cast能用于多态向上转换，向下转换能成功，但是结果未知

### 5.3  dynamic_cast

用于动态类型转换，只能用于含有虚函数的类，用于类层次间的向上和向下转换。

向上转换：子类向基类的转换；向下转换：基类向子类的转换；

### 5.4  reinterpreter_cast

几乎什么都可以转，比如int转指针，非常危险；

C的强制类型转换没有错误检查，容易出错。

## 6 C++指针和引用的区别

- 指针有自己的一块空间，而引用只是一个别名；

-  使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；

- 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；

- 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；

-  可以有const指针，但是没有const引用；

- 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；

- 指针可以有多级指针（**p），而引用至于一级；

- 指针和引用使用++运算符的意义不一样；

- 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

## 7 C++中的智能指针

C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。

为什么要使用智能指针：

 智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

### 7.1  auto_ptr（c++98的方案，cpp11已经抛弃）

采用所有权模式。

auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));

auto_ptr<string> p2;

p2 = p1; //auto_ptr不会报错.

此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！

### 7.2unique_ptr（替换auto_ptr）

 

unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。

采用所有权模式，还是上面那个例子

unique_ptr<string> p3 (new string ("auto"));  //#4

unique_ptr<string> p4；            //#5

p4 = p3;//此时会报错！！

编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。

另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：

unique_ptr<string> pu1(new string ("hello world"));

unique_ptr<string> pu2;

pu2 = pu1;                   // #1 not allowed

unique_ptr<string> pu3;

pu3 = unique_ptr<string>(new string ("You"));  // #2 allowed

其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。

注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：

unique_ptr<string> ps1, ps2;

ps1 = demo("hello");

ps2 = move(ps1);

ps1 = demo("alexia");

cout << *ps2 << *ps1 << endl;

 

### 7.3  shared_ptr

 

shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。

 

shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。

 

成员函数：

 

use_count 返回引用计数的个数

 

unique 返回是否是独占所有权( use_count 为 1)

 

swap 交换两个 shared_ptr 对象(即交换所拥有的对象)

 

reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少

 

get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的

 

### 7.4  weak_ptr

 

weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

 

class B;

class A

{

public:

shared_ptr<B> pb_;

~A()

{

cout<<"A delete\n";

}

};

class B

{

public:

shared_ptr<A> pa_;

~B()

{

cout<<"B delete\n";

}

};

void fun()

{

shared_ptr<B> pb(new B());

shared_ptr<A> pa(new A());

pb->pa_ = pa;

pa->pb_ = pb;

cout<<pb.use_count()<<endl;

cout<<pa.use_count()<<endl;

}

int main()

{

fun();

return 0;

}

可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。

 

注意的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print();

 

## 8 构造函数为什么不能为虚函数？

构造函数不能声明为虚函数的原因是:

1 构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象 的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。无法确定

2 虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初 始化，将无法进行。虚函数的意思就是开启动态绑定，程序会根据对象的动态类型来选择要调用的方法。然而在构造函数运行的时候，这个对象的动态类型还不完整，没有办法确定它到底是什么类型，故构造函数不能动态绑定。

 

## 9  public继承，protect继承，private继承

|           |           | 继承方式  |           |         |            |
| --------- | --------- | --------- | --------- | ------- | ---------- |
|           |           | public    | protected | private | 在派生类中 |
| 基类成员  | public    | public    | protected | private |            |
| protected | protected | protected | private   |         |            |
| private   | 不可用    | 不可用    | 不可用    |         |            |

### 9.1  public继承

从语义角度上来说，public继承是一种接口继承（可以理解为子类对象可以调用父类的接口，也就有可能实现多态了）

   从语法角度上来说，public继承后，关系见上图。很明显父类public成员在子类中仍然是public，所以子类对象可以调用父类的接口

### 9.2  protected继承

从语义角度上来说，protected继承是一种实现继承从语法角度上来说，protected继承后，父类public和protected成员都变成子类的protected成员了，也就是说子类对象无法调用父类的接口，只能将父类的函数当作子类的内部实现，当然也就不符合“Liskov替换原则（LSP）”了。

### 9.3  private继承

² 从语义角度上来说，private继承是一种实现继承

² 从语法角度上来说，private继承后，父类public和protected成员都变成子类的private了，它比protected继承更严格。也就说这些父类的成员只能被继承一次，再继续继承，父类的成员就不可见了。private继承更不符合“Liskov替换原则（LSP）”了。

 

## 10 多态是怎么实现的，举例？虚函数多态是怎么实现的？

多态分为静态多态和动态多态

静态多态：函数重载和运算符重载，复用函数名，编译阶段确定函数地址

例子：实现同一功能函数的返回值和参数列表不同，加法运算函数，不同的形参类型，不同的返回值类型，编译时结合形参和返回值类型映射为另一个函数。

动态多态：继承+虚函数实现，运行阶段确定函数地址

每个包含虚函数的类都包含一个虚表，虚表是一个指针数组，其中存放着虚函数的指针，每个元素对应一个虚函数的函数指针。虚函数指针的赋值发生在编译器的编译阶段，代码编译时，虚表就被构造出来了。当派生类继承基类时，也会继承基类的函数调用权，一个类继承了包含虚函数的类，这个类也会有自己的虚表。

派生类重写基类的虚函数后，派生类对应的虚表中的函数地址替换为自己的函数地址，实例化对象后，基类指针指向派生类的对象（就是派生类内容按基类的结构进行解释），通过基类指针可以访问派生类的_vptr，从而访问到子类具体的虚函数实现。

## 11 std::enable_if的用法

std::enable_if 顾名思义，满足条件时类型有效。作为选择类型的小工具，其广泛的应用在 C++ 的模板元编程（meta programming）中。它的定义也异常的简单 

```cpp
template <bool, typename T=void>

struct enable_if {

};

 template <typename T>

struct enable_if<true, T> {

 using type = T;

};
```

利用了偏特化，只有当第一个模板参数为true时，type才有定义，否则使用type将会产生错误

### 11.1类型偏特化

```cpp
template <typename T, typename Enable=void>
struct check;
 
template <typename T>
struct check<T, typename std::enable_if<T::value>::type> {
  static constexpr bool value = T::value;
}; 
```



### 11.2控制函数返回类型





## 12 CLion+Google test 测试框架配置

Google_tests文件下包含：

test文件

CMakeList文件：需要同时链接到google test lib和Target test lib

lib下为google test源代码



Test_lib为待测试的库，封装为一个静态库

其下有工程的源文件和CMakeList，生成静态库



## 13 STL序列式容器

1 vector是一段连续空间，内部包括：寻找新的空间，复制源空间，删除原空间的操作

2 list是非连续空间，维护一个node

3 deque是看起来连续的非连续空间，维护一个map，map的每个pointer指向一个连续空间

4 stack是适配器，可以由deque和list配接实现

5 queue也是适配器，同样可以由deque和list两种实现方式

6 priority_queue允许用户以任何次序将任何元素推入容器内，但取出时一定是从优先权最高的元素开始取。

binary heap是一种完全二叉树（complete binary tree），整棵二叉树除了最底层的叶节点外，是填满的，最底层的叶节点由左到右又不得有空隙。

根据元素的排列，heap可分为max-heap和min-heap两种，前者每个节点的键值都大于等于其子节点的键值，后者每个节点的键值都小于等于其自节点的键值，因此max-heap的最大值在根节点，min-heap的最小值在根节点。STL中heap的实现是：vector+heap算法

## 14 LRU算法

## 15 Linux内容

进程调度、内存管理、文件系统、设备模块、网络模块