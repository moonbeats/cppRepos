#include <iostream>
using namespace std;
/**
 * 一、构造函数和析构函数的构造规则

1、派生类可以不定义构造函数的情况 当具有下述情况之一时，派生类可以不定义构造函数。 基类没有定义任何构造函数。 基类具有缺省参数的构造函数。 基类具
有无参构造函数。
2、派生类必须定义构造函数的情况 当基类或成员对象所属类只含有带参数的构造函数时，即使派生类本身没有数据成员要初始化，它也必须定义构造函数，并以构造
函数初始化列表的方式向基类和成员对象的构造函数传递参数，以实现基类子对象和成员对象的初始化。
3、派生类的构造函数只负责直接基类的初始化

C++语言标准有一条规则：如果派生类的基类同时也是另外一个类的派生类，则每个派生类只负责它的直接基类的构造函数调用。 这条规则表明当派生类的直接基类只
有带参数的构造函数，但没有默认构造函数时（包括缺省参数和无参构造函数），它必须在构造函数的初始化列表中调用其直接基类的构造函数，并向基类的构造函数
传递参数，以实现派生类对象中的基类子对象的初始化。 这条规则有一个例外情况，当派生类存在虚基类时，所有虚基类都由最后的派生类负责初始化。

总结： （1）当有多个基类时，将按照它们在继承方式中的声明次序调用，与它们在构造函数初始化列表中的次序无关。当基类A本身又是另一个类B的派生类时，则先
 调用基类B的构造函数，再调用基类A的构造函数。

（2）当有多个对象成员时，将按它们在派生类中的声明次序调用，与它们在构造函数初始化列表中的次序无关。

（3）当构造函数初始化列表中的基类和对象成员的构造函数调用完成之后，才执行派生类构造函数体中的程序代码。
 */

class A
{
private:
    int x;
public:
    A(int aa):x(aa){cout<<"Constructing A"<<endl;}
    ~A(){cout<<"Destructing A"<<endl;}
};

class B:public A
{
public:
    B(int x):A(x){cout<<"Constructing B"<<endl;}

};
class C:public B
{
public:
    C(int y):B(y){cout<<"Constructing C"<<endl;}
};
int main() {
    C c(1);
    system("pause");
    return 0;
}

/**
 * 当同时存在直接基类和间接基类时，每个派生类只负责其直接基类的构造
 */
